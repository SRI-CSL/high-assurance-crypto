# Maurer Next Message EasyCrypt Formalization

This folder contains a formalization for an instantiation of the generic MPC-in-the-head construction with the Maurer's MPC protocol. It includes a generic formalization of the 'Next-Message' protocol format; a Jasmin implementation with the low-level protocol (with associated correctness proofs); as well as the instantiation of the abstract infrastructure.


## Contents

* folder `jasmin` - Jasmin implementation and generic proof support for multi-precision numbers
  - `eclib` - Jasmin EC library (distributed with the Jasmin language verficiation infrastructure - (https://github.com/jasmin-lang/jasmin));
  - `eclib_extra/JBigNum.ec` - extensions to the Jasmin EC library (support for multi-precision number representation)
  - `src` - Jasmin implementation
    - `Maurer5_jazz.jazz` (1059 loc): implementation of Maurer's protocol;
    - `bn_generic.jazz, bn_p25519.jazz`: field operations for prime 25519;
    - `Fp_small.jazz, Fp_bool.jazz`: field operations for small primes (up to 2^64) and booleans;
    - `*.ec, *.s`: Easycrypt and Assembly files generated by the Jasmin compiler
* folder `tools` - `ecml` tool, that translates EasyCrypt's operator language into OCaml
* folder `proof` - main Easycrypt formalization
  * `EC`: Auxiliary definitions and proofs for EasyCrypt base theories
  * `MitH`: Abstract protocol interfaces and security definitions, imported from the generic MitH formalization
  * `Maurer`: EasyCrypt specification of the Maurer MPC protocol implemented in Jasmin and imported from the Maurer formalization
    - `FieldOps/`: correctness proofs for field operations (p25519, small modulus and boolean);
    - `Maurer5SS, Maurer5Spec`: Specification of the passively secure Maurer MPC protocol for 5 parties
    - `Maurer5SSCompat`: Proof that the replicated secret-sharing scheme used in the Maurer specification satisfies the secret sharing security notion required for the generic MitH proofs.
    - `Maurer5_jazz_Zp*: specification and correctness proof of Maurer's protocol with 5 parties;
  * `NextMsg`: Abstract formalization of MPC protocol execution and security following the next messages style
    - `NextMsgArray`: Abstract theory for arrays with fixed size
    - `NextMsgTrace`: Abstract types for the traces produced by a MPC protocol execution following the next message style
    - `NextMsgProtocol`: Abstract formalization of MPC protocols that execute as a series of rounds, following the next message style
    - `NextMsgStatefulProtocol`: Refinement of abstract next message style MPC protocols that allows protocols to maintain state in-between rounds
    - `NextMsgCircuit`: Abstract formalization of MPC protocols that evaluate a circuit as a sequence of gates, and where each gate corresponds to a protocol round in the next messages style
    - `NextMsgWeak`: Abstract weaker notion of security for MPC protocols whose secret inputs and secret outputs are secret shares and that do not reveal secure information. This will be the security notion for individual gates and is composable
    - `NextMsgMPC`: Abstract security definitions for MPC protocols with public outputs
    - `NextMsgMPCReveal`: Abstract definitions for composing a weakly secure MPC protocol with a final reveal step that reveals the output.
    - `NextmsgMPCRevealProofs`: Proof that a weak MPC protocol followed by a final reveal provides standard MPC security
    - `NextMsgWeakCircuit`: Abstract formalization of MPC protocols that evaluate a circuit with weak security
    - `NextMsgWeakCircuitProofs`: Proof that an abstract MPC protocol that evaluates a circuit achieves weak MPC security by composing similarly weak MPC secure gates
  * `NextMsgMaurer`: Instantiation of the abstract formalization for the Maurer MPC protocol
    - `NextMsgMaurer`: Instantiation of the next messages protocol interface using the Maurer specification
    - `NextMsgMaurerAuxProofs`: Auxiliary proofs specific to the replicated secret-sharing scheme used in the Maurer specification
    - `NextMsgMaurerAddProofs`: Proof that the Maurer addition gate satisfies our weak security notions
    - `NextMsgMaurerSMulProofs`: Proof that the Maurer scalar multiplication gate satisfies our weak security notions
    - `NextMsgMaurerConstProofs`: Proof that the Maurer constant gate satisfies our weak security notions
    - `NextMsgMaurerMulProofs`: Proof that the Maurer multiplication gate satisfies our weak security notions
    - `NextmsgMaurerProofs`:
        1. Proof that a Maurer gate (addition, scalar multiplication, constant or multiplication) satisfies weak security
        2. The proof of weak security for Maurer circuits comes for free from the abstract weak circuit formalization and proofs
        3. Proof of the standard MPC security of the whole protocol, combining the weakly secure circuit evaluation with a final reveal step. We instantiate the abstract weak + reveal proof and prove only the necessary axioms
    - `NextMsgMaurerCompat`: Compatibility layer that instantiates the abstract MPC protocol interface used in the MitH proofs with our Maurer protocol
    - `NextMsgMaurerCompatProofs`: Proof that our Maurer instantiation satisfies all the MPC correctness and consistency properties required by the generic MitH formalization
    - `NextMsgMaurerCompatPrivacyProofs`: Proof that our Maurer instantiation satisfies the MPC security notion required by the generic MitH formalization


## Dependencies

For verifying the proofs scripts, a working installation of Easycrypt is needed (tested with `Easycrypt commit: 4c419f4`, with provers `Z3-8.4.10` and `alt-ergo-2.4.0`).
For processing the Jasmin code, a working installation of the Jasmin Infrastructure is needed (check details in (https://github.com/jasmin-lang/jasmin)).

The docker image given at the top-level directory includes both EasyCrypt and Jasmin tools.

Additionally to the EasyCrypt to OCaml extraction tool used for the generic MitH and the BGW implementation, For extracting part of the OCaml implementation code from the Maurer EasyCrypt formalization we have written a custom translation tool (dubbed `ecml`) that follows the semi-automated extraction strategy described in the paper. For compiling this tool, a working installation of Haskell is needed.

The docker image given at the top-level directory also includes the pre-compiled `ecml` tool. To re-compile it inside the docker image, you may run the following commands:

```bash
$> apt install haskell-platform
$> cabal update
$> cd /home/mith/mith-maurer/tools && cabal install ecml.cabal
$> cp $HOME/.cabal/bin/ecml /usr/local/bin/ecml
```

## Verifying the EasyCrypt formalization

The proof scripts of this formalization can be verified using the following command:

`$> make check`

For convenience, we have included in the distribution the generated code from the Jasmin compiler (assembly code and EasyCrypt models). To (re)generate them, please type:

`$> (cd jasmin/src; make all)`

## Extracting executable OCaml code

For convenience, we have included in the `implementation-maurer` folder the extracted code from the `mith-maurer` implementation. To (re)generate these files, please type:

`$> make extract`

It will take a while. All the OCaml files that are completely extracted from the Maurer formalization will be regenerated and copied to the `implementation-maurer/src/MPC/Maurer` folder. The remaining files in the `implementation-maurer/src/MPC/Maurer` folder have also been automatically extracted from our EasyCrypt formalization using our extraction tools, but some concrete definitions of types and operators have been filled or adjusted manually.
